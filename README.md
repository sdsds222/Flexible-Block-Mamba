# Smart-Zipper-Mamba

步骤一：全局双向扫描 (O(N) 并行)

动作：首先，我们并行运行两个全局的 Mamba 扫描器（一个正向，一个反向）。

输出：我们得到两个完整的、未经修改的“单向建议”序列：

Y_f (从 t=1 到 N 的正向输出序列)

Y_b (从 t=N 到 1 的反向输出序列)

步骤二：拓宽视野 (“宽拉链头”)

动作：我们将 Y_f 和 Y_b 沿着“通道”维度拼接 (Concat) 起来，得到一个“双通道”的序列 Y_in。

关键创新：我们不直接使用 Y_in。相反，我们用一个一维卷积 (Conv1D)（比如 kernel_size=3 或 5）来处理 Y_in。

输出：我们得到一个新的“摘要”序列，Y_local_context。

作用：在 t 时刻的 Y_local_context[t]，不再是“近视”的，它已经是一个融合了 t 时刻及其邻居（如 t-1, t+1）信息的**“宽视野摘要”**。

步骤三：计算智能门控 (基于“宽视野”)

动作：我们把这个“宽视野摘要” (Y_local_context) 喂给两个独立的门控网络 (MLP)。

输出：两个“维度级”的门控向量 g_f 和 g_b。

g_f = Sigmoid(MLP_f(Y_local_context))

g_b = Sigmoid(MLP_g(Y_local_context))

作用：g_f 和 g_b 是“拉链头”做出的智能决策，它基于一个短语（而不是一个词）来决定融合比例。

步骤四：维度级融合 (“拉链咬合”)

动作：我们使用上一步计算出的智能门控 g_f 和 g_b，来对步骤一中的原始 Y_f 和 Y_b 进行逐元素的加权融合。

最终输出 (Y_t)： Y_t = (g_f[t] * Y_f[t]) + (g_b[t] * Y_b[t]) (这里的 * 是逐元素乘法)

拓展设想：
1) 决策地图（ConvMap）

用多尺度/膨胀 Conv1D 在输入嵌入上并行生成三类信号：
(a) 块长类别（从少量候选如 64/128/256 中选）；
(b) 分支需求/权重（是否需要反向/双向，或连续门控系数）；
(c) 合并节点的子算子门控系数（控制该子块在本次父节点合并中的影响强度）。

地图仅依赖局部输入（不依赖前缀状态），确保后续“先出块摘要→一次块级扫描”的并行范式不被破坏。

2) 自适应分块 + 分桶

将相邻同类决策合并为段，并量化到少数“内核友好”块长；

以 (块长 × 分支类型) 为键分桶并行，避免负载不均，复用 Mamba-2 的块内并行内核。

3) 双分支独立块摘要

正向与反向两条分支各自对所有块并行计算零初始块摘要（块对状态的仿射作用/本地输出），与 Bi-Mamba 一致。

块间只保留一次块级 pass-states 扫描（短序列），主干仍为 O(N)。

4) 树上“节点级算子门控”（核心创新）

在每次上行合并（两个子块 → 父块）前，依据地图对参与合并的子算子施加线性门（“双向标注→放大”“单向标注→减弱”），再执行父算子合成；

门控设计为对“子摘要与恒等”的线性混合，不改接口维度、仍属仿射类，从而保持可结合→可用并行前缀/树形扫描。

5) 传状态与块内展开

对“已门控合成”的块摘要序列做一次 pass-states（前缀扫描）得到真实起始状态；

在各自分支内展开块内输出；块级再做前/后向线性融合。推理时对低门控的反向块硬跳过以省算力。

6) 并行与复杂度要点

并行性：地图并行、块内并行、分桶并行、一次块级扫描；

结合律前提：门控需线性可折叠，使“块摘要合并”仍为固定、具单位元、可结合的规约；

复杂度：主干 O(N)；仅增加轻量路由/门控开销。

7) 训练最小配置

离散决策可微化：块长/是否反向用 Gumbel-Softmax（训期软、推理期硬）；

计算预算正则：对“大块/反向”使用加权代价，逼迫“按需”启用；

平滑：对地图输出做轻度平滑/滞回，稳定切段与分桶。

一句话：Conv1D 并行出“块长/分支/节点门控”地图 → 自适应分块+分桶 → 双分支各自块摘要 → 在树的合并处对“子算子”线性门控 → 一次 pass-states → 块内展开与块级融合。既保留 Mamba-2 的并行与 O(N)，又把双向与计算强度精准投向“该用的地方”。
