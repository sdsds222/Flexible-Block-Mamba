# Flexible Block Mamba


**简介**

Flexible Blocks Mamba 在不改动 Mamba 高度并行的主干的前提下，实现“先按最小块划分 → 并行卷积打分 → 只在同父内合并属性相同的相邻块 → 生成指导地图”。这样既保留一次块级扫描与高并行 O(N)，又把算力按需投向关键片段，并可对局部片段执行反向（REV）以增强建模能力。


**核心思想：** 在不改变 Mamba 高度并行的核心 SSM 结构的前提下，通过一个**快速、可并行**的预处理流程生成一个“指导地图”，实现**计算资源的按需投向**（动态分块）和**局部建模能力的增强**（局部反向，REV）。


#### **步骤一：按最小块 $L_0$ 切分**

* **操作：** 将输入序列 $X = [x_1, x_2, \dots, x_N]$ 按预先设定的超参数 $L_0$（例如 $L_0=64$）等距、不重叠地切分成最小块 $B_0[i]$。
    * $B_0[i] = [x_{i \cdot L_0 + 1}, \dots, x_{(i+1) \cdot L_0}]$
* **目的/意义：**
    1.  **确定最小粒度：** 奠定后续所有判断和合并操作的最小单位。
    2.  **保证并行与对齐：** $L_0$ 块通常会设计成 GPU 上 Mamba 块内核（Block Kernel）能高效处理的尺寸，确保后续操作的并行性和对齐性。

#### **步骤二：卷积并行打分与属性标注**

* **操作：**
    1.  **并行特征提取：** 使用少量多尺度或空洞）**的 $Conv1D$ 模块，一次性并行处理整个序列 $X$。这利用了卷积的高并行性，快速捕获局部和多尺度的上下文特征。
    2.  **块级聚合与打分：** 对每个 $L_0$ 块的卷积输出特征进行池化聚合（如 $\text{mean}/\text{max}/\text{std}$），然后通过一个轻量级 $MLP$ 得到该块的**摘要**和**评分结果**。
    3.  **属性标注：** 根据评分结果，为每个最小块 $B_0[i]$ 标注其属性，例如：
        * **一致性/相似度：** 块内部信息的同质性。
        * **方向性：** 关键信息是向前依赖（默认）还是需要回顾性建模（REV）。
* **目的：** 快速、并行地为每个基础计算单元提供一个可用于后续合并和分桶的**“身份标识”**。

#### **步骤三：同父合并（严格二叉对齐）**

* **操作：** 这是一个**层次化、自底向上**的合并过程，严格遵循二叉树结构，**只在同一父节点内**检查相邻块是否满足合并条件。
    1.  **Level 1 检查（$2 \cdot L_0$）：** 检查相邻的最小块对 $(B_0[2j], B_0[2j+1])$ 的属性（来自步骤二的评分）是否一致或相似。
        * **如果通过：** 合并为 $B_1[j]$（一个 $2 \cdot L_0$ 的块）。
        * **如果未通过：** 它们保持为两个独立的 $L_0$ 块，不再参与更高层的合并。
    2.  **检查：** 检查相邻的 $B_{k-1}$ 块对 $(B_{k-1}[2k], B_{k-1}[2k+1])$ 是否一致。若一致，则合成 $B_k$（一个 $2^k \cdot L_0$ 的块）。
    3.  **迭代：** 重复此过程，直到无法继续合并（即所有相邻的同父块对都不再相似）。
* **目的：**
    1.  **实现动态稀疏化：** 将同质区域合并成更大的块，减少 Mamba 核心算子需要处理的块总数，从而节省计算资源。
    2.  **按需分配算力：** 属性差异大的关键片段被保留为小块，获得更高的计算分辨率。

#### **步骤四：相邻同性质区域再合并（可选的进一步稀疏化）**

* **操作：** 在步骤三结束后，如果发现最终输出中存在多个**同层（如都停留在 $2 \cdot L_0$ 或 $4 \cdot L_0$）**且**同属性**的相邻块，可以继续尝试向上合并。
    * **约束：** 必须在**二叉约束**下进行，**不允许跨越原始父节点边界**。
* **目的：** 进一步减少块的总数，提高效率。

#### **步骤五：局部反向（REV）增强建模能力**

* **操作（前置反转）：**
    1.  识别最终指导地图中**标注为 REV** 的块（例如，根据步骤二的评分，判断该块内的信息流需要回顾）。
    2.  在将序列送入 Mamba **之前**，**直接在输入上反转该子序列**的顺序。
        * 例如：如果 $B_{rev} = [x_a, x_{a+1}, \dots, x_b]$ 被标记为 REV，则实际送入 Mamba 的是 $[x_b, x_{b-1}, \dots, x_a]$。
* **目的：**
    1.  **零侵入的双向建模：** Mamba 本质上是单向 SSM。通过前置反转，Mamba 仍是单向扫描，但对于这个局部片段来说，它捕获了反向回顾的依赖关系，增强了该关键区域的建模能力，同时兼容 Mamba 主干。

#### **步骤六：生成指导地图**

* **操作：** 将步骤三、四和五的结果汇总，生成最终的指导地图。
* **指导地图内容案例：** 一组元组 $(\text{start}_i, \text{length}_i, \text{type}_i, \text{flags}_i)$。
    * $\text{start}_i, \text{length}_i$：确定了 Mamba 块内核要处理的子序列范围（来自合并结果）。
    * $\text{type}_i$：分桶类型，如“高强度 SSM”、“低强度 SSM”、“恒等”等（来自属性标注或节点门控）。
    * $\text{flags}_i$：指示是否已经进行了“局部反转（REV）”等额外信息。
* **目的：** 明确告诉 Mamba 核心算子**“做什么、在哪里做、做什么类型”**。

#### **步骤七：按地图执行 Mamba（核心计算）**

* **操作：**
    1.  **分桶与块级并行：** 按地图中的 $\text{type}_i$ 对块进行分桶。仅对这些块运行 Mamba 的**块内核（Block Kernel）**，实现块内并行计算。
    2.  **块摘要序列生成：** 计算每个块的输出摘要 $H_i$。
    3.  **块级前缀扫描：** 对块摘要序列 $[H_1, H_2, \dots]$ 执行一次**块级前缀扫描**（Prefix Sum/Scan），以得到 Mamba 理论中的真实起始状态（即 $\text{Mamba} \rightarrow \text{Mamba}$ 的状态传递）。
        * 这确保了 Mamba 的**全局依赖**和**状态关联**得以维持，同时利用了硬件加速。

---

### **拓展设想（节点级算子门控）讲解**

* **核心思想：** 不仅控制**哪些块合并**，还要控制**合并时使用多强的 SSM 算子**。
* **操作：** 在每次上行合并（两个子块 $\rightarrow$ 父块）前，基于步骤二的属性地图，对参与合并的子块摘要施加一个**线性门控**（$G$）。
    * **门控函数设计：** $H_{\text{父}} = \text{SSM}(\text{Gate}(H_{\text{子}_1}), \text{Gate}(H_{\text{子}_2}))$。
    * **Gate 的形式：** $\text{Gate}(H) = \alpha \cdot H + (1-\alpha) \cdot \text{Identity}(H)$（摘要 $H$ 与恒等 $I$ 的线性混合）。
        * **门控驱动：** 例如，若标注为“双向”，则放大 $REV$ 门控 $\alpha$；若标注为“单向”，则减弱 $REV$ 门控 $\alpha$。
* **目的：**
    1.  **精细化控制：** 将反向/双向/计算强度更精准地投向关键的**节点/上下文**，而非仅仅是整个块。
    2.  **保持并行性：** 由于门控被设计为对子摘要与恒等的**线性混合**，它属于**仿射变换**，不改变接口维度，且能保持 Mamba 状态传递的**可结合律（Associativity）**，因此仍可使用**并行前缀扫描**或**树形扫描**高效实现。





